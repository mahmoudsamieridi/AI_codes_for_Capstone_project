# -*- coding: utf-8 -*-
"""AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bYQRACXvzqPtPRIrnWoHZq_lC1C72T0D
"""

!pip install ultralytics
import cv2
import pickle
import numpy as np
from ultralytics import YOLO
from google.colab.patches import cv2_imshow
import time
from IPython.display import clear_output
import requests
import threading
import subprocess  # Ù…ÙƒØªØ¨Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ´ØºÙŠÙ„ FFmpeg
import os
import signal

#  Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª API
API_URL = 'https://phonal-shelli-friskily.ngrok-free.dev/api/cv/update-spots'
API_KEY = 'cv_api_a9d7c1e9b5f845f8a8f91a24deafb329'
LOCATION_ID = '0ac25ec4-308f-4b70-944c-1ea6e922facb'
GATE_ID = '6198c6d5-39ba-4273-9d14-716a349ce07c'

def send_data_to_api(spots_payload):
    headers = { "Content-Type": "application/json", "X-CV-API-KEY": API_KEY }
    body = { "locationId": LOCATION_ID, "gateId": GATE_ID, "spots": spots_payload }

    try:
        requests.post(API_URL, json=body, headers=headers, timeout=2)
    except:
        pass # ØªØ¨Ø³ÙŠØ· Ù„Ù„ÙƒÙˆØ¯ ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„ØªØ¬Ù†Ø¨ ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„Ø³ØªØ±ÙŠÙ…

# ==========================================
# ğŸ¥ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (FFmpeg Stream)
# ==========================================

VIDEO_PATH = '/content/drive/MyDrive/cv/carPark.mp4'
STREAM_URL = 'udp://127.0.0.1:23000' # Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„ÙˆÙ‡Ù…ÙŠ Ù„Ù„Ø¨Ø«

# Ø£Ù…Ø± FFmpeg:
# -re : ÙŠÙ‚Ø±Ø£ Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© (Real-time) Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
# -stream_loop -1 : ÙŠÙƒØ±Ø± Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ù„Ø§ Ù†Ù‡Ø§Ø¦ÙŠØ©
# -f mpegts : ØµÙŠØºØ© Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¨Ø« Ø¹Ø¨Ø± Ø§Ù„Ø´Ø¨ÙƒØ©
ffmpeg_cmd = [
    'ffmpeg',
    '-y', # Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„ÙÙˆÙ‚ÙŠØ©
    '-re',
    '-stream_loop', '-1',
    '-i', VIDEO_PATH,
    '-f', 'mpegts',
    '-codec:v', 'mpeg1video', # ÙƒÙˆØ¯Ùƒ Ø®ÙÙŠÙ ÙˆØ³Ø±ÙŠØ¹
    '-b:v', '1000k', # Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù€ Bitrate
    '-r', '30', # ØªØ«Ø¨ÙŠØª Ø§Ù„ÙØ±ÙŠÙ… Ø±ÙŠØª
    STREAM_URL
]

# Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ© FFmpeg Ø³Ø§Ø¨Ù‚Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø§Ø±Ø¶
os.system("pkill -f ffmpeg")

print("[INFO] Starting FFmpeg Stream Simulation...")
# ØªØ´ØºÙŠÙ„ FFmpeg ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
ff_proc = subprocess.Popen(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# Ù†Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø­ØªÙ‰ ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø¨Ø«
time.sleep(2)

# ==========================================
#  Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙˆØ§Ù„Ù…Ø¬Ø³Ø§Øª
# ==========================================

LAYOUT_FILE = '/content/drive/MyDrive/cv/parking_layout_new2.pkl'
SENSOR_W, SENSOR_H = 20, 20

try:
    with open(LAYOUT_FILE, 'rb') as f:
        sensorList = pickle.load(f)
    print(f"[INFO] Loaded {len(sensorList)} sensors.")
except:
    print("[ERROR] Layout file not found!")
    sensorList = []

previous_states = [None] * len(sensorList)

print("[INFO] Loading YOLO Model...")
model = YOLO('https://huggingface.co/mshamrai/yolov8s-visdrone/resolve/main/best.pt')

# ğŸ‘‡ Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø¬ÙˆÙ‡Ø±ÙŠ: Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù† Ø±Ø§Ø¨Ø· Ø§Ù„Ù€ UDP Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ù…Ù„Ù
print(f"[INFO] Connecting to Stream: {STREAM_URL}")
cap = cv2.VideoCapture(STREAM_URL)

PROCESS_W, PROCESS_H = 1280, 720
DISPLAY_W, DISPLAY_H = 1020, 600

frame_skip = 5 # ÙŠÙ…ÙƒÙ† Ø²ÙŠØ§Ø¯ØªÙ‡Ø§ Ù„Ø£Ù† Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø£Ø³Ø±Ø¹
count = 0
first_run = True

try:
    while True:
        ret, frame = cap.read()

        if not ret:
            print("[WARNING] Frame dropped or stream disconnected. Retrying...")
            time.sleep(0.1)
            # ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø³ØªØ±ÙŠÙ… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ù„Ø§ Ù†ÙƒØ³Ø± Ø§Ù„Ù„ÙˆØ¨ Ø¨Ù„ Ù†Ø­Ø§ÙˆÙ„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¬Ø¯Ø¯Ø§Ù‹
            # Ø¥Ø°Ø§ ØªÙˆÙ‚Ù Ø§Ù„Ø¨Ø« ØªÙ…Ø§Ù…Ø§Ù‹ ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© ÙØªØ­ Ø§Ù„Ù€ cap
            continue

        count += 1
        if count % frame_skip != 0: continue

        frame_process = cv2.resize(frame, (PROCESS_W, PROCESS_H))

        # YOLO Prediction
        results = model.predict(frame_process, conf=0.15, verbose=False)

        car_boxes = []
        for r in results:
            for box in r.boxes:
                x1, y1, x2, y2 = box.xyxy[0]
                area = (x2 - x1) * (y2 - y1)
                if area > 800:
                    car_boxes.append([int(x1), int(y1), int(x2), int(y2)])

        occupied_count = 0
        frame_display = frame_process.copy()
        updates_to_send = []

        for i, sensor_pos in enumerate(sensorList):
            sx1, sy1 = sensor_pos
            sx2, sy2 = sx1 + SENSOR_W, sy1 + SENSOR_H
            spot_id = i + 1
            is_occupied = False

            for car in car_boxes:
                cx1, cy1, cx2, cy2 = car
                # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ø§Ø·Ø¹
                ix1 = max(sx1, cx1); iy1 = max(sy1, cy1)
                ix2 = min(sx2, cx2); iy2 = min(sy2, cy2)
                inter_w = max(0, ix2 - ix1)
                inter_h = max(0, iy2 - iy1)
                if (inter_w * inter_h) > (SENSOR_W * SENSOR_H * 0.3):
                    is_occupied = True
                    break

            if first_run or (is_occupied != previous_states[i]):
                updates_to_send.append({
                    "spotNumber": spot_id,
                    "isOccupied": is_occupied
                })
                previous_states[i] = is_occupied

            # Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª
            color = (0, 0, 255) if is_occupied else (0, 255, 0)
            if is_occupied: occupied_count += 1
            cv2.rectangle(frame_display, (sx1, sy1), (sx2, sy2), color, 2)

        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Thread)
        if updates_to_send:
            threading.Thread(target=send_data_to_api, args=(updates_to_send,)).start()

        first_run = False

        # Ø§Ù„Ø¹Ø±Ø¶
        frame_final = cv2.resize(frame_display, (DISPLAY_W, DISPLAY_H))
        cv2.putText(frame_final, f'Free: {len(sensorList) - occupied_count}',
                    (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

        cv2_imshow(frame_final)
        clear_output(wait=True)

except KeyboardInterrupt:
    print("[INFO] Stopping...")

finally:
    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù
    cap.release()
    ff_proc.kill() # Ù‚ØªÙ„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù€ FFmpeg
    print("[INFO] FFmpeg process killed.")